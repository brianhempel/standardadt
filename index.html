<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
	<meta charset="utf-8"/>
	<title>Standard Algebraic Data Types</title>
</head>
<body>

<h1 id="standardalgebraicdatatypes">Standard Algebraic Data Types</h1>

<p>Algebraic data types let you express not only your data, but also its shape and its variations.</p>

<p>Real world data, has a shape, also called a <em>schema</em>.</p>

<p>A JSON file is data-only. Humans learn by example, so you can <em>usually</em> guess the schema by looking at a JSON object. But what if there are other possible variations? You have to go to the docs to learn about variations and details. But even then, the documentation may be incomplete or ambiguous, and computers can&#8217;t read documentation so there&#8217;s no guarantee that the actual API follows the documentation.</p>

<p>Standard ADT schemas are:</p>

<ol>
<li><strong>Unambiguous.</strong> ADTs express variants. Will this field be ever be <code>null</code>? ADTs tell you. Perhaps the API lists both registered users and anonymous users in the same responseâ€”what fields are available on each kind? ADTs make it clear.</li>
<li><strong>Enforceable.</strong> An API that publishes a standard ADT schema can and should verify that all its responses match the schema. You can trust the API will do what it says and will not break your code.</li>
<li><strong>Readable.</strong> Standard ADT schemas can be read by humans or computers. You can understand the data and appropriate classes or data types in your language of choice can be automatically generated from an ADT schema, as can the code to transform Standard ADT responses into objects in your language.</li>
</ol>

<p>A standard ADT response always contains the schema <em>and</em> the data. So you, and you computer, can interpret what you have received.</p>

<h2 id="schema">Schema</h2>

<p>Primitives are:</p>

<table>
<colgroup>
<col />
<col />
</colgroup>

<thead>
<tr>
	<th> Primitive             </th>
	<th> Description             </th>
</tr>
</thead>

<tbody>
<tr>
	<td> <code>Int</code>              </td>
	<td> Arbitrary precision integer.         </td>
</tr>
<tr>
	<td> <code>IntN</code> <code>UIntN</code> e.g. <code>Int32</code> <code>UInt64</code>      </td>
	<td> Signed/unsigned integers of various power-of-two sizes. Equivalent to <code>Int</code> with a refinement of <span class="math">\(-2^{N-1} \le n &lt; 2^{N-1}\)</span> for signed and <span class="math">\(0 \le n &lt; 2^N\)</span> for unsigned integers. </td>
</tr>
<tr>
	<td> <code>Rational = Rational { numerator: Int, denominator: Int }</code> </td>
	<td> Arbitrary precision rational number.       </td>
</tr>
<tr>
	<td> <code>Float32</code> <code>Float64</code> <code>Float128</code>        </td>
	<td> IEEE floating point numbers of various sizes.    </td>
</tr>
<tr>
	<td> <code>CharUTF8</code>             </td>
	<td> A single UTF-8 character.         </td>
</tr>
<tr>
	<td> <code>List a</code>             </td>
	<td> A list containing elements of some type <code>a</code>.     </td>
</tr>
<tr>
	<td> <code>StringUTF8</code>            </td>
	<td> <span class="math">\(\equiv\)</span> <code>List CharUTF8</code>          </td>
</tr>
<tr>
	<td> `Optional a = Some a </td>
	<td> None`        </td>
	<td> Optionally contains a value of some type <code>a</code>, or no value. In other words, this field may be <code>null</code>. </td>
</tr>
</tbody>
</table>

<p>Refinements:</p>

<h2 id="data">Data</h2>

<p>Data looks like</p>

</body>
</html>

